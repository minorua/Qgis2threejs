# Component Communication and Timing (Qgis2threejs)

Created: January 24, 2026

Note: This document was generated by AI (GitHub Copilot, GPT-5).

This guide explains the data and signal communication between the core components that drive the preview/export pipeline: Q3DController, TaskManager, ThreeJSBuilder, Layer Builders, Q3DWebBridge, Web Page, and JavaScript World. It focuses on both the contents of messages exchanged and when they occur.

References:
- Controller: [core/controller/controller.py](core/controller/controller.py)
- Task manager: [core/controller/taskmanager.py](core/controller/taskmanager.py)
- Builder: [core/build/builder.py](core/build/builder.py)
- Layer builders: [core/build/vector/builder.py](core/build/vector/builder.py), [core/build/dem/builder.py](core/build/dem/builder.py), [core/build/pointcloud/builder.py](core/build/pointcloud/builder.py)
- Web bridge and views: [gui/webbridge.py](gui/webbridge.py), [gui/webengineview.py](gui/webengineview.py), [gui/webkitview.py](gui/webkitview.py), [gui/webviewcommon.py](gui/webviewcommon.py)
- Viewer HTML/JS: [web/viewer/webengine.html](web/viewer/webengine.html), [web/viewer/viewer.js](web/viewer/viewer.js)
- Data shapes: [docs/data_structure.md](docs/data_structure.md)

---

## Overview

- Q3DController orchestrates preview initialization, task sequencing, and data dispatch to the web viewer.
- TaskManager queues and schedules tasks (scene, layer builds, script runs) and signals the controller to execute them one at a time.
- ThreeJSBuilder generates scene and layer data, streaming blocks with progress and signaling completion/failure.
- Layer Builders produce layer envelopes and block payloads for DEM, vector, and point cloud types.
- Q3DWebBridge delivers data and status between Python and JS; Web Page runs scripts and forwards bridge signals; JavaScript World applies `loadData()` and renders.

---

## Wiring: Signals and Slots

All connections are set up in `ConnectionManager.setup()` and torn down in `teardown()`.

- Web Page → Controller
  - **`loadFinished(bool)`**: Triggers `Q3DController.pageLoaded(ok)`.

- Web Bridge → Controller
  - **`initialized()`**: Triggers `Q3DController.viewerInitialized()` after JS completes core initialization.
  - **`dataLoaded()`**: Triggers `Q3DController.dataLoaded()` once JS consumes a data packet.

- Task Manager → Controller
  - **`executeTask(object)`**: Triggers `Q3DController.executeTask(task)` to run the next queued item.
  - **`abortCurrentTask()`**: Triggers `Q3DController.abortCurrentTask()`.
  - **`allTasksFinalized()`**: Notifies controller that the task queue is empty.

- Controller → Builder
  - **`buildSceneRequest(ExportSettings)`**: Calls `ThreeJSBuilder.buildSceneSlot(settings)`.
  - **`buildLayerRequest(Layer, ExportSettings)`**: Calls `ThreeJSBuilder.buildLayerSlot(layer, settings)`.

- Builder → Controller
  - **`dataReady(dict)`**: Calls `Q3DController.appendDataToSendQueue(data)` to enqueue payload for JS.
  - **`progressUpdated(int,int,str)`**: Calls `Q3DController.builderProgressUpdated(current,total,msg)`.

- Builder → Task Manager
  - **`taskCompleted()`**: Calls `TaskManager.taskCompleted()`.
  - **`taskFailed(str,str)`**: Calls `TaskManager.taskFailed(target, traceback_str)`.
  - **`taskAborted()`**: Calls `TaskManager.taskAborted()`.

Cross-thread connections (when the builder runs in a worker `QThread`) are queued automatically by Qt.

---

## Content: What Gets Sent

### Controller → Web Page (JS)

- **Scripts**: `runScript(string)` carries commands like `init(...)`, `app.start()`, `setPreviewEnabled(...)`, `setBackgroundColor(...)`, `tasksAndLoadingFinalized(complete,isScene)`, etc.
- **Script files**: `loadScriptFiles([ScriptFile...])` loads JS libraries (e.g., loaders for 3D models, Potree) before building certain layers.
- **Data**: `sendData(data, viaQueue)` delivers JSON packets consumed by `viewer.js:loadData()`.

### Builder → Controller (data payloads)

- **Scene**: `{ "type": "scene", "properties": { baseExtent, origin, zScale, light, fog?, proj? } }`.
- **Layer**: `{ "type": "layer", "id": jsLayerId, "properties": { name, clickable, visible, type, ... }, "body": { materials | models?, blocks? } }`.
- **Block**: `{ "type": "block", "layer": jsLayerId, "block": index, ... }` containing vector features or DEM grid/mesh parts. Vector export may instead return `{ "url": ..., "featureCount": N }`.
- **Progress hint**: For streamed blocks, builder adds `data["progress"] = ThreeJSBuilder.currentProgress` so JS can update the progress bar immediately.

See [docs/data_structure.md](docs/data_structure.md) for full JSON shapes.

### JS → Bridge → Controller

- **`emitInitialized()`**: JS calls after `init()` completes. Controller responds by enabling app and queueing scene build.
- **`emitDataLoaded()`**: JS calls after `loadData()` completes; unblocks controller send queue.
- **`emitSceneLoaded()`**: JS calls after scene and subsequent finalization; used by UI to reflect completion.
- **Other events**: tween/animation, image/model save, rendering finished (`emitRequestedRenderingFinished()`), and status messages.

---

## Timing: When Things Happen

### 1) Page Load and JS Initialization

- Web Page loads [web/viewer/webengine.html](web/viewer/webengine.html) or [web/viewer/webkit.html](web/viewer/webkitview.py#L38-L76), which includes [viewer.js](web/viewer/viewer.js).
- Controller’s `pageLoaded(ok)` runs:
  - Applies configuration scripts (north arrow, navigation, coord mode).
  - Calls `init(offScreen, DEBUG_MODE, QGIS_VERSION_INT, isWebEngine)` via `runScript()`.
- In JS `init()`:
  - Establishes `pyObj` bridge and connects `pyObj.sendData` (WebEngine) or defines `pyData()` (WebKit).
  - Calls `_init()` to build renderer, events, loading manager; then `pyObj.emitInitialized()`.

### 2) Viewer Initialized → Start App → Queue Scene Build

- Controller `viewerInitialized()`:
  - Sends labels (`{type:"labels"}`) if configured.
  - Calls `app.start()` so the viewer begins rendering.
  - Enqueues scene build: `TaskManager.addBuildSceneTask()`.

### 3) Task Dispatch (TaskManager)

- `TaskManager.processNextTask()` pulses the queue with a single-shot timer.
- `executeTask(item)` is emitted to the controller, which routes to:
  - `buildScene()` → `buildSceneRequest.emit(settingsCopy)`.
  - `buildLayer(layer)` → optional `loadScriptFiles(...)`, then `buildLayerRequest.emit(layer, settingsCopy)`.
  - `updateSceneOptions()` → `runScript()`.
  - `runScript`/`sendData` dicts → `runScript()` or enqueue data.

### 4) Builder Work and Streaming

- `ThreeJSBuilder.buildSceneSlot()` builds the scene JSON and emits `dataReady(scene)` then `taskCompleted()`.
- `ThreeJSBuilder.buildLayerSlot()`:
  - Emits `dataReady(layer)` with layer envelope.
  - Iterates `layerBuilder.blockBuilders()`:
    - Checks `aborted`; if set, emits `taskAborted()` and returns.
    - Builds a block; sets `data["progress"]`; emits `dataReady(block)`.
  - Emits `taskCompleted()`.

Layer Builders:
- Vector: [core/build/vector/builder.py](core/build/vector/builder.py) batches features into blocks; each block contains `features`, `featureCount`, `startIndex`.
- DEM: [core/build/dem/builder.py](core/build/dem/builder.py) yields material blocks and grid/mesh blocks per tile or resampled extent; grid payload may be base64/binary/url.
- Point cloud: [core/build/pointcloud/builder.py](core/build/pointcloud/builder.py) emits a lightweight layer descriptor that points to Potree assets.

### 5) Controller Send Queue and JS Acknowledgement

- On `dataReady(data)`, controller enqueues the packet and calls `sendQueuedData()` if idle.
- `sendData(data, viaQueue=True)` forwards to Web Page:
  - WebEngine: `bridge.sendData.emit(data, viaQueue)`.
  - WebKit: stores data in bridge (`bridge.setData`) then runs `loadData(pyData(), viaQueue)`.
- In JS `loadData()`:
  - Marks `preview.isDataLoading` true when `viaQueue`.
  - Routes `scene`/`layer`/`block` to `app.loadData()` and updates progress bar when `data.progress` exists.
  - When loading finishes, triggers `app.dispatchEvent({type:"loadComplete"})` → `pyObj.emitDataLoaded()`.
- Controller `dataLoaded()`:
  - Clears `isDataLoading`; if queued data remain, sends next packet.
  - If tasks are finalized and no more data are queued, calls `tasksAndLoadingFinalized(complete,is_scene)`.

### 6) Finalization and UI Feedback

- Controller ensures `TaskManager.taskSequenceStatus.allTasksFinalized` and no pending send work.
- Runs `tasksAndLoadingFinalized(complete,isScene)` via `runScript()`.
- In JS `tasksAndLoadingFinalized()`:
  - Hides the progress bar.
  - If `complete && isScene`, schedules `app.dispatchEvent({type:"sceneLoaded"})` → `pyObj.emitSceneLoaded()`.

### 7) Abort Path

- UI/user or controller triggers `abortCurrentTask()` → `Q3DController.abort(clear_tasks=False)`:
  - Sets builder `aborted = True`.
  - Clears send queue as needed.
- Builder checks `aborted` between blocks; emits `taskAborted()`.
- TaskManager resets `isTaskRunning` and schedules next or finalizes.

---

## Payload Examples (JS `loadData()` routing)

- `{type:"labels", Header:String, Footer:String}` → updates DOM labels.
- `{type:"cameraState", state:Object}` → restores camera.
- `{type:"animation", tracks:Array, repeat:Boolean}` → starts tween-based animation.
- `{type:"block", layer:Number, block:Number, features:Array, featureCount:Number, startIndex:Number}` → vector features.
- DEM variants include `{grid:{base64|binary|url}, translate, width/height, zScale, materials, sides, edges}` or clipped triangle meshes.

---

## Improvement Opportunities

- **Back-pressure on send queue**: The controller’s `sendQueue` can grow without bounds when JS is slow. Impose a queue limit and rate control, or batch multiple small blocks per `dataReady` to reduce signal chatter. See discussion in [docs/refactoring_proposals.md](docs/refactoring_proposals.md).
- **Unify finalization state**: Merge task completion and data-loading completion into a single state machine (extend `SceneLoadStatus`) and gate finalization through a `maybeFinalize()` function called from both `taskFinalized()` and `dataLoaded()`.
- **Task timer pacing**: Replace the `QTimer.setInterval(1)` pulse with event-driven scheduling (`QTimer.singleShot(0)` triggered by task enqueue/completion) to avoid unnecessary wakeups.
- **Early abort checks**: Add `aborted` checks in inner loops (feature/material/model building) to reduce wasted work on large layers.
- **Exception propagation**: In `Q3DController.executeTask()`, propagate exceptions to `TaskManager.taskFailed()` and finalize to keep the queue moving; avoid broad `except Exception` masks where targeted handling is possible.
- **Cross-thread safety**: Audit QGIS API calls made from the worker thread and marshal unsafe calls back to the UI thread via signals or `QMetaObject.invokeMethod`.
- **Batching blocks**: Update `ThreeJSBuilder.buildLayerSlot()` to accumulate multiple blocks and emit a single `dataReady({type:"blockBatch", blocks:[...]})`, adding viewer support to consume batches efficiently.

---

## Quick Code Map

- Wiring: [ConnectionManager.setup](core/controller/controller.py#L19-L66)
- Controller queue & load ack: [appendDataToSendQueue](core/controller/controller.py#L214-L241), [dataLoaded](core/controller/controller.py#L243-L259)
- Finalization: [allTasksFinalized](core/controller/controller.py#L230-L242), [tasksAndLoadingFinalized](core/controller/controller.py#L262-L273), JS [viewer.js:tasksAndLoadingFinalized](web/viewer/viewer.js#L287-L307)
- Task sequencing: [TaskManager.processNextTask](core/controller/taskmanager.py#L88-L111), [TaskManager.taskFinalized](core/controller/taskmanager.py#L156-L179)
- Builder streaming: [ThreeJSBuilder.buildLayerSlot](core/build/builder.py#L67-L116)
- Layer builders: Vector [blockBuilders](core/build/vector/builder.py#L176-L251), DEM [blockBuilders](core/build/dem/builder.py#L80-L116)
- JS data path: [viewer.js:init/loadData](web/viewer/viewer.js#L12-L93), [loadData](web/viewer/viewer.js#L100-L146), [progress](web/viewer/viewer.js#L309-L321)

---

## Summary

The plugin uses Qt signals/slots to decouple UI, task sequencing, data generation, and rendering. Data flows as JSON through a thin bridge, and timing coordination hinges on three events: task dispatch/completion, data load acknowledgment from JS, and finalization. Applying the proposed pacing, batching, and state unification can make large-scene builds more robust and responsive.

---

## Prompt

Please analyze the codebase of this project and explain the data and signal communication between the following components, including both the content of the communication and its timing:

- Q3DController
- TaskManager
- ThreeJSBuilder
- Layer Builders
- Q3DWebBridge
- Web Page
- JavaScript World

If there are any aspects of the data or signal communication that could be improved, please include an explanation of those potential improvements as well.

Please provide the explanation as a Markdown file.
