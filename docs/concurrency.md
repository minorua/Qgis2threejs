# Qgis2threejs Concurrency Guide

Created: January 24, 2026

Note: This document was generated by AI (GitHub Copilot, GPT-5).

This guide explains Qgis2threejs’ threading and concurrency design in PyQt/QGIS. It’s intended for developers who want to understand, maintain, or extend the plugin.

## Overview

Qgis2threejs separates interactive UI work from long-running scene and layer building work by moving the builder to an optional worker thread. UI remains responsive while data generation proceeds asynchronously and is streamed to the viewer.

- UI thread: All Qt widgets, the 3D viewer, and routing of tasks and data through signals.
- Worker thread: `ThreeJSBuilder` when background building is enabled; performs CPU- and I/O-heavy scene and layer generation.
- Asynchronous messaging: Qt signals/slots connect the UI and builder across thread boundaries; task sequencing is coordinated by a lightweight `TaskManager`.

Configuration:
- `RUN_BLDR_IN_BKGND` controls whether the builder runs in a worker thread ([conf.py](../conf.py#L18)).
- The preview window uses background threading by default ([gui/window.py](../gui/window.py#L62)), while off-screen export runs in the UI thread ([core/export/export.py](../core/export/export.py#L346)).

## Core Components

- `Q3DWindow` (UI): Hosts menus, tree view, and the WebEngine/WebKit viewer; wires actions to controller tasks ([gui/window.py](../gui/window.py)).
- `Q3DController` (UI): Orchestrates tasks, moves builder to `QThread` when enabled, streams data to the web page, and manages cancellation ([core/controller/controller.py](../core/controller/controller.py)).
- `TaskManager` (UI): Queues and sequences tasks via a `QTimer`, emitting work items to the controller ([core/controller/taskmanager.py](../core/controller/taskmanager.py)).
- `ThreeJSBuilder` (Worker or UI): Builds scene and layers, emitting `dataReady`, `taskCompleted`, `taskFailed`, and progress updates ([core/build/builder.py](../core/build/builder.py)).
- `WebBridge` and `WebPage` (UI): Bridge Python <-> JS for data delivery, status, and rendering events ([gui/webbridge.py](../gui/webbridge.py)).

## Thread Separation

- Builder thread: When `useThread=True`, the controller creates a `QThread`, moves the builder into it, and starts the thread’s event loop ([core/controller/controller.py](../core/controller/controller.py#L116-L133)).
- Teardown: Controller requests the builder to `quit()` and move back to the main thread before stopping the worker thread ([core/controller/controller.py](../core/controller/controller.py#L73-L95)). The builder implements `quit()` to call `moveToThread(QgsApplication.instance().thread())` ([core/build/builder.py](../core/build/builder.py#L45-L63)).
- Non-threaded mode: For off-screen exports, the builder runs in the UI thread to simplify interaction with QGIS APIs ([core/export/export.py](../core/export/export.py#L334-L361)).

## Signal/Slot Communication

Wiring is centralized in `ConnectionManager.setup()` ([core/controller/controller.py](../core/controller/controller.py#L30-L70)):

- Web page → Controller
  - `loadFinished(bool)` → `pageLoaded(bool)`.
- Web bridge → Controller
  - `initialized()` → `viewerInitialized()`.
  - `dataLoaded()` → `dataLoaded()` (acknowledges JS has consumed a data packet).
- Controller → Builder (cross-thread when enabled)
  - `buildSceneRequest(ExportSettings)` → `ThreeJSBuilder.buildSceneSlot()`.
  - `buildLayerRequest(Layer, ExportSettings)` → `ThreeJSBuilder.buildLayerSlot()`.
- Task manager → Controller
  - `executeTask(object)` → `executeTask(object)` (dispatches next item).
  - `abortCurrentTask()` → `abortCurrentTask()`.
  - `allTasksFinalized()` → `allTasksFinalized()`.
- Builder → Controller
  - `dataReady(dict)` → `appendDataToSendQueue(dict)`.
  - `progressUpdated(int,int,str)` → `builderProgressUpdated(int,int,str)`.
- Builder → Task manager
  - `taskCompleted()` → `taskCompleted()`.
  - `taskFailed(str,str)` → `taskFailed(str,str)`.
  - `taskAborted()` → `taskAborted()`.

Qt automatically uses queued connections across threads, ensuring slot invocations occur in the receiver’s thread.

## Task Sequencing and Back-Pressure

- Queueing: UI actions enqueue tasks (`BUILD_SCENE`, `UPDATE_SCENE_OPTS`, layer builds, reloads) into `TaskManager.taskQueue` ([core/controller/taskmanager.py](../core/controller/taskmanager.py#L33-L39)).
- Dispatch: A single-shot `QTimer` pulses the queue, emitting `executeTask(item)` while tracking `isTaskRunning` ([core/controller/taskmanager.py](../core/controller/taskmanager.py#L63-L101)).
- Completion/Failure: Builder emits `taskCompleted` or `taskFailed`, which resets `isTaskRunning` and schedules the next item ([core/controller/taskmanager.py](../core/controller/taskmanager.py#L113-L154)).

Data delivery to the viewer is paced by a send queue in `Q3DController`:

- Producer: Builder emits `dataReady(dict)`; controller enqueues and calls `sendData()` if not loading ([core/controller/controller.py](../core/controller/controller.py#L214-L241)).
- Consumer ack: JS calls `bridge.emitDataLoaded()` after consuming a packet, triggering `controller.dataLoaded()` to send the next item ([gui/webbridge.py](../gui/webbridge.py#L36-L70), [core/controller/controller.py](../core/controller/controller.py#L243-L259)).
- Finalization: When both tasks and loading are done, controller informs JS via `tasksAndLoadingFinalized(complete,isScene)` ([core/controller/controller.py](../core/controller/controller.py#L178-L192)).

## Cancellation/Abort

- User-triggered abort: `TaskManager.abortCurrentTask` connects to `Q3DController.abortCurrentTask`, which calls `abort(clear_tasks=False)` ([core/controller/controller.py](../core/controller/controller.py#L196-L212)).
- Builder-aware abort flag: `ThreeJSBuilder.aborted` is guarded by a threading lock when off the UI thread; long loops check the flag between blocks and emit `taskAborted` ([core/build/builder.py](../core/build/builder.py#L17-L39), [core/build/builder.py](../core/build/builder.py#L82-L120)).
- Queue cleanup: `Q3DController.abort()` can clear the task queue and send queue; `TaskManager.removeBuildLayerTask()` aborts a specific layer if currently processing ([core/controller/controller.py](../core/controller/controller.py#L168-L194), [core/controller/taskmanager.py](../core/controller/taskmanager.py#L103-L141)).

## Logging Across Threads

Logs can be forwarded to the UI via a Qt signal-emitting handler so messages are delivered safely across thread boundaries ([utils/logging.py](../utils/logging.py#L52-L91)). UI attaches a slot to display logs (e.g., Web console) ([gui/window.py](../gui/window.py#L86-L104)).

## Known Limitations

- QGIS thread-safety: Many QGIS core APIs are not fully thread-safe. Builder code accesses QGIS objects (e.g., `QgsFeatureRequest`, `QgsCoordinateTransform`, map rendering jobs) off the UI thread in preview mode. This generally works but can be fragile across QGIS versions.
- Coarse-grained cancellation: Abort checks occur primarily between feature blocks. Long operations in `build()` (e.g., feature iteration, material/model preparation) don’t observe the abort flag, delaying cancellation.
- Unbounded send queue: `Q3DController.sendQueue` can grow without explicit limits if JS is slow to consume data, potentially increasing memory usage.
- Tight task timer: `TaskManager` uses a 1 ms single-shot timer to pulse the queue, which can create rapid dispatch cycles. While cooperative, this may contribute to work being scheduled faster than results are consumed.
- Minor API mismatch: Export code references `ConnectionManager.setupConnections()` while the controller defines `setup()`. Ensure consistency when modifying connection setup ([core/export/export.py](../core/export/export.py#L332-L356), [core/controller/controller.py](../core/controller/controller.py#L30-L70)).

## Suggested Improvements

- Adopt `QgsTask`/`QgsTaskManager`: Integrate with QGIS’ task framework for better progress reporting, cancellation, and concurrency control aligned with QGIS best practices.
- Strengthen cancellation points: Add `if builder.aborted: ...` checks in inner loops (feature iteration, material/model building, image rendering). Propagate early returns to avoid wasted work.
- Back-pressure and pacing: Bound `sendQueue` or pause producers when queue grows beyond a threshold; consider flow-control signals from JS (e.g., “ready for next”) instead of optimistic streaming.
- Safer QGIS API access: Audit builder operations for QGIS API calls; where thread-safety is questionable, marshal those specific calls to the UI thread via signals or `QMetaObject.invokeMethod` with `Qt.QueuedConnection`.
- Replace ad-hoc task timer: Drive task sequencing from explicit builder completion events without the extra `QTimer` pulse, or use a small state machine to reduce edge-case timing races.
- Standardize connection setup: Unify `ConnectionManager` API (`setup` vs `setupConnections`), and centralize all signal wiring to avoid drift.
- Explicit queued connections: Where cross-thread signals are performance-critical, specify `Qt.QueuedConnection` to avoid implicit connection type ambiguity.
- Unit tests for concurrency: Add tests that simulate aborts during long builds, measure queue growth under slow JS consumption, and validate correct finalization ordering.

## Developer Tips

- Keep all GUI operations strictly on the UI thread.
- Ensure any shared state accessed from the worker is protected (Python `Lock` or Qt `QMutex`) and avoid sharing Qt objects without clear ownership.
- Prefer signals/slots for cross-thread communication; avoid calling methods on objects in other threads directly.
- When adding new builders, emit progress regularly to keep the UI responsive and to surface abort checks.
- Validate behavior on both WebEngine and WebKit modes; their event timing differs.

---

## Prompt

Write “Qgis2threejs Concurrency Guide” as a Markdown file that explains the plugin’s threading and concurrency design in PyQt / QGIS. The guide should describe how the UI thread and a worker thread are separated, and how they communicate using Qt signals and slots. It is intended for developers who want to understand, maintain, or extend the plugin. The guide should also identify problems or limitations in the current codebase and suggest possible improvements to the concurrency design.