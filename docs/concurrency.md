# Qgis2threejs Concurrency Guide

Created: December 23, 2025

Note: This document was generated by AI (GitHub Copilot, GPT-5).

This guide explains how Qgis2threejs handles threading and concurrency under PyQt and QGIS. It is intended for developers who want to understand, maintain, or extend the plugin.

## Overview

- The plugin separates UI work (QGIS main thread) from heavy scene/layer building via an optional worker `QThread`.
- In the preview window, builders run in a background thread by default, controlled by `RUN_BLDR_IN_BKGND` (see [conf.py](../conf.py)).
- In Processing/export workflows, builders typically run in the UI thread to simplify synchronous rendering and avoid QGIS Processing threading (see [core/processing/procalgorithm.py](../core/processing/procalgorithm.py)).

## Key Components

- `Q3DWindow` creates the controller with threading enabled for preview: see [gui/window.py](../gui/window.py).
- `Q3DController` orchestrates tasks, owns a `QThread` when enabled, and wires signals/slots between the UI and the builder: see [core/controller/controller.py](../core/controller/controller.py).
- `ThreeJSBuilder` does heavy work (scene/layer building). It is moved to a worker thread when threading is enabled and communicates progress/data via Qt signals: see [core/build/builder.py](../core/build/builder.py).
- `Q3DViewInterface` is the UI-facing bridge that accepts data (JSON-like dicts) and forwards them to the web view for rendering: see [gui/webviewcommon.py](../gui/webviewcommon.py).

## UI Thread vs Worker Thread

- UI Thread (main thread):
  - Owns widgets, web view/page, and `Q3DController`.
  - Schedules tasks via a small `QTimer` tick and maintains a queue to avoid blocking interactions.
  - Receives `dataReady` from the builder and forwards data to the page (`sendData`).
- Worker Thread (optional):
  - `Q3DController` creates a `QThread` and moves `ThreeJSBuilder` with `moveToThread()`.
  - Starts the worker event loop with `thread.start()`.
  - Builder slots are marked `@pyqtSlot` so they execute in the worker context after cross-thread signal delivery.

### Thread Lifecycle

- Construction:
  - Preview: `Q3DWindow` sets `useThread=RUN_BLDR_IN_BKGND`, creating a `QThread` in `Q3DController` and moving the builder.
  - Export/Processing: `Q3DController` is created without a worker thread; builder runs on the UI thread.
- Teardown:
  - `Q3DController.teardown()` aborts pending work, quits the worker thread when present (`thread.quit()`/`thread.wait()`), and tears down the interface connections.

## Signals and Slots (Communication)

- Controller Interface → Builder:
  - `buildSceneRequest` → `ThreeJSBuilder.buildSceneSlot()`
  - `buildLayerRequest(Layer)` → `ThreeJSBuilder.buildLayerSlot(layer)`
- Builder → Controller and View:
  - `dataReady(dict)` → `Q3DViewInterface.sendData(data)` (UI thread)
  - `taskCompleted()` / `taskAborted()` → `Q3DController.taskFinalized()` (unblocks queue, clears status)
- Controller → UI:
  - `statusMessage(str, int)` updates the status bar.
  - `progressUpdated(int, str)` updates the progress bar/text.

All cross-thread deliveries use Qt’s queued connections automatically (QObject signal/slot across threads), ensuring UI updates occur on the main thread.

## Task Scheduling and Cancellation

- `Q3DController` keeps a FIFO queue of tasks: build scene, build visible layers, run script snippets, update options, reload.
- A single-shot `QTimer` (`interval=1ms`) pumps the queue so the UI remains responsive.
- Cancellation:
  - `Q3DController.abort()` sets the builder’s `aborted` flag and optionally clears the queue.
  - `ThreeJSBuilder` checks `self.aborted` during build loops and emits `taskAborted()` if set.
  - In UI-thread mode, `aborted` access calls `QgsApplication.processEvents()` to keep the UI responsive during long loops.
  - In worker-thread mode, `aborted` is protected by a Python `Lock` to ensure thread-safe reads/writes.

## Network and Asynchronous Operations

- `Downloader` (gsielevtile plugin) manages multiple concurrent `QNetworkReply`s using `QEventLoop` and `QTimer` for timeouts: see [plugins/gsielevtile/downloader.py](../plugins/gsielevtile/downloader.py).
- It emits `replyFinished(url)` per reply and `allRepliesFinished()` when all are done; this class typically runs in whichever thread owns it but relies on the Qt event loop.

## Known Limitations and Risks

- Single Worker Thread:
  - The builder runs in one worker thread; layer building is sequential. There’s no `QThreadPool` parallelism for blocks or layers.
- UI-Thread Build Path:
  - Processing/export path executes builder in the UI thread, relying on `QgsApplication.processEvents()` to avoid UI freeze. This can introduce reentrancy and subtle side effects.
- Teardown Subtleties:
  - Teardown includes direct `thread.quit()`/`wait()` but leaves commented alternative pathways. Signal disconnection is done via a list but does not explicitly guard against late emissions to deleted receivers.
- Shared State Safety:
  - `ExportSettings`, `ImageManager`, and per-layer properties can be mutated while building; only the `aborted` flag is protected by a lock. There’s no broader synchronization or immutable snapshotting per task.
- Qt Network Manager Thread Affinity:
  - `QgsNetworkAccessManager.instance()` is application-global; using it from non-UI threads requires care. If `Downloader` is moved off the main thread, verify thread affinity and queued delivery of signals.
- Backpressure and Progress Granularity:
  - `progressUpdated` is high-level; lengthy operations inside builders may not emit fine-grained progress, limiting cancel responsiveness.

## Recommendations for Improvement

- Unify Background Execution:
  - Run heavy work in a worker thread for both preview and export to eliminate UI-thread builds and `processEvents()` usage.
- Introduce `QThreadPool`/`QRunnable`:
  - Parallelize block-level work within layers where safe (DEM tiles, vector blocks) to improve throughput while keeping a single marshaling point to the UI.
- Snapshot Settings per Task:
  - Clone `ExportSettings` (and derived configs) at queue enqueue time, pass immutable snapshots to builders to avoid concurrent mutation hazards.
- Strengthen Cancellation:
  - Replace Python `Lock` with a Qt-friendly atomic flag (e.g., a small `QObject` with `pyqtSignal` cancel or a `QReadWriteLock` if needed). Ensure frequent checks inside inner loops and network callbacks.
- Explicit Connection Types:
  - Use `Qt.QueuedConnection` explicitly for cross-thread connects to make intent clear, especially when connecting to UI update slots.
- Robust Teardown:
  - Connect `thread.finished` to a cleanup slot; block signals (`QSignalBlocker`) during teardown; disconnect builder emissions and null-check receivers before emitting.
- Safer Network Use in Workers:
  - If moving `Downloader` off the UI thread, create a thread-local `QNetworkAccessManager` or marshal requests to the main thread with queued signals/slots.
- Better Progress and Backpressure:
  - Emit granular progress from builders; consider pausing/resuming via signals; add max queue length or coalescing strategies for rapid property changes.

## Extending the Concurrency Design

- When adding new long-running operations:
  - Implement them inside a `QObject` moved to the worker thread.
  - Expose `@pyqtSlot` entry points and emit status/data via signals.
  - Never touch UI objects from the worker; marshal updates through the controller/interface.
- Example pattern:

```python
class MyWorker(QObject):
    started = pyqtSignal()
    finished = pyqtSignal()
    dataReady = pyqtSignal(dict)

    @pyqtSlot(object)
    def doWork(self, task):
        self.started.emit()
        # Heavy work here, check cancel flag frequently
        result = {"type": "layer", "body": {...}}
        self.dataReady.emit(result)
        self.finished.emit()

# In controller setup
thread = QThread(self)
worker = MyWorker()
worker.moveToThread(thread)
worker.finished.connect(thread.quit)
thread.start()

# Cross-thread call
self.iface.buildLayerRequest.connect(worker.doWork)  # queued
worker.dataReady.connect(self.iface.sendData)        # queued back to UI
```

## References (Code)

- Preview controller creation and threading toggle: [gui/window.py](../gui/window.py)
- Controller, queue, worker management: [core/controller/controller.py](../core/controller/controller.py)
- Builder, signals, abort lock: [core/build/builder.py](../core/build/builder.py)
- View interface (UI thread marshaling): [gui/webviewcommon.py](../gui/webviewcommon.py)
- Processing algorithm flags (disables QGIS threading): [core/processing/procalgorithm.py](../core/processing/procalgorithm.py)
- Downloader (network concurrency with event loop): [plugins/gsielevtile/downloader.py](../plugins/gsielevtile/downloader.py)

---

If you’d like, we can prototype `QThreadPool` block-level workers and wire them into `ThreeJSBuilder` behind a feature flag to validate performance and safety before making it the default.

---

Prompt:
> Write a “Qgis2threejs Concurrency Guide” that explains the plugin’s threading and concurrency design under PyQt / QGIS. The guide should describe how the UI thread and a worker thread are separated, and how they communicate using Qt signals and slots. This guide is intended for developers who want to understand, maintain, or extend the plugin. Also point out problems or limitations in the current code and suggest possible improvements to the concurrency design.
