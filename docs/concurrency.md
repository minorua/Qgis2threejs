# Qgis2threejs Concurrency Guide

Created: November 19, 2025

Note: This document was generated by AI (GitHub Copilot, GPT-5).

This guide explains Qgis2threejs's concurrency (threading/task) design for contributors. The current implementation follows PyQt/QGIS threading constraints and separates UI from build processing with minimal asynchrony.

## Overview

- UI thread: QGIS UI, `Q3DWindow`, `Q3DViewerInterface`, WebView (`webPage`), dialogs/tree views.
- Worker thread: `Q3DController` and its children (`Q3DControllerInterface`, `ThreeJSBuilder`, `ImageManager`, layer builders).
- Signal-based IPC: Threads communicate via Qt signals/slots (queued connections). The worker emits JSON data/scripts/progress to the UI; the UI emits build requests to the worker.

By default, `conf.RUN_CNTLR_IN_BKGND = True`, so when a preview page is available, `Q3DController` is moved to a `QThread` and runs there.

## Files and Key Classes

- UI thread
  - `gui/window.py`:
    - `Q3DWindow`: Main plugin window. When `RUN_CNTLR_IN_BKGND` is True and WebView is available, creates a `QThread` and moves `Q3DController` into it.
    - `Q3DViewerInterface`: Subclass of `Q3DInterface`. Emits build/settings change requests from the UI to the controller.
- Worker thread
  - `core/controller/controller.py`:
    - `Q3DController`: Processes the build queue for scenes/layers.
    - `Q3DControllerInterface`: Bridge from controller to UI (data send, script execution, progress, status).
  - `core/build/builder.py`:
    - `ThreeJSBuilder`: Builds JSON-compatible objects for scenes/layers.; requests helper scripts when necessary.
  - `core/build/datamanager.py`:
    - `ImageManager`: Renders and caches map/layer images (using QGIS renderer).
- Notes
  - `core/processing/procalgorithm.py`: QGIS Processing algorithms set `FlagNoThreading` (run on UI/main thread).

## Responsibilities Across Threads

- UI thread
  - Operate the WebView (`webPage.runScript`, `sendData`, etc.)
  - Display and update widgets
  - Settings load/save UI and dialogs
- Worker thread
  - Build scenes/layers (generate JSON-compatible objects)
  - Schedule build requests (`requestQueue` and `QTimer`)
  - Compute based on the worker-side copy of `ExportSettings`

The two sides communicate loosely through signals via `Q3DControllerInterface` and `Q3DInterface`.

## Typical Flow

1. Start-up
   - `Q3DWindow` creates `Q3DController(settings, thread)`, connects, and after `thread.start()` the controller has been moved to the thread.
   - `controller.connectToIface(viewerIface)` wires controller and UI-side interface signals.
2. Build request
   - The UI calls `Q3DViewerInterface.requestBuildScene|requestBuildLayer|requestRunScript` and emits corresponding signals to the controller.
   - The controller enqueues the request in `requestQueue` and drives `_processRequests()` with a `QTimer`.
3. Build
   - `ThreeJSBuilder` and layer builders generate JSON-compatible objects.
   - After each unit, the controller emits `iface.dataSent.emit(obj)` (UI then sends to WebView) and progress updates.
4. Shutdown
   - `Q3DWindow.closeEvent` emits `iface.quitRequest` → `Q3DController.quit()` → waits for `readyToQuit`, then `QThread.quit()`/`wait()`.

## Thread-Boundary Rules (Do/Don't)

- Do
  - Operate UI objects (`webPage`, widgets) only on the UI thread.
  - Notify UI from the worker exclusively via `Q3DControllerInterface` signals.
  - Send UI→worker requests exclusively via `Q3DViewerInterface` signals.
  - Coalesce repeated requests for the same layer in the queue (existing logic in `requestBuildLayer`).
- Don't
  - Call QWidget or `webPage` methods directly from the worker.
  - Update shared state concurrently without protection (especially `ExportSettings`).
  - Call `QgsApplication.processEvents()` in the worker casually (GUI event loop is UI-thread oriented).

## Shared Objects and Access Patterns

- Owned/operated in worker
  - `requestQueue`, `QTimer`, `processingLayer`, `enabled`, `aborted`
  - `ThreeJSBuilder` and layer builders, `ImageManager`
- Shared read/write
  - `ExportSettings` (scene/camera/navigation/preview/layers/widget settings). UI-side changes are reflected into the worker via signals (`updateExportSettings`, `requestBuildLayer`).
- Via UI indirection (signals only)
  - `webPage` operations (send data, execute scripts)
- QGIS-dependent (requires care)
  - Read `QgsMapCanvas.mapSettings()` (to refresh extent before rebuild)
  - `ImageManager.renderedImage()` uses `QgsMapRendererCustomPainterJob` and temporarily modifies `QgsMapSettings`

## Known Caveats and Improvements

1. Sharing `ExportSettings`
   - Current: UI modifies settings then the worker’s `settings` is updated via `copyTo()`.
   - Recommendation: Pass a snapshot (deep copy) UI→worker and update only the worker’s copy to avoid two-way concurrent edits.
2. Temporary modification of `QgsMapSettings`
   - `ImageManager.renderedImage()` swaps output size/extent/rotation/layers/background and restores afterward.
   - Risk: Multiple threads touching the same `QgsMapSettings` can cause inconsistencies.
   - Recommendation: Delegate rendering to the UI thread (signal request → deliver result) so the worker only consumes the rendered image.
3. `QgsApplication.processEvents()`
   - Avoid calling it from the worker. Re-evaluate necessity; either remove or shift dependent code to the UI side.
4. Queue coalescing
   - There is room for stronger debounce/throttle of frequent updates for the same layer.

## Code Snippets (Excerpts)

- Moving the controller to worker thread (`gui/window.py`)

```python
self.thread = QThread(self) if self.webPage and RUN_CNTLR_IN_BKGND else None
self.controller = Q3DController(settings, self.thread)
if self.thread:
    self.thread.finished.connect(self.controller.deleteLater)
    self.thread.finished.connect(self.thread.deleteLater)
    self.thread.start()
```

- Inter-thread communication (`core/controller/controller.py`)

```python
# Send data to UI
def sendJSONObject(self, obj):
    self.dataSent.emit(obj)  # UI calls webPage.sendData

# Script request
self.scriptSent.emit(string, data, msg)
```

## Future Work

- Snapshot/immutable model for `ExportSettings`
- UI-thread delegation API for rendering (request/response façade)
- Stronger queue merging/debounce for high-frequency events
- Lightweight thread-safety guards and assertions

---
If you find discrepancies or unclear parts, please open an Issue/PR.